<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/general.css">
    <link rel="stylesheet" href="../css/authentication.css">
    <link rel="stylesheet" href="../css/wallet.css">
    <title>Cross-site Request Forgery</title>
</head>
<body>
    <script src="../scripts/ui.js" onload="load_color_mode();"></script>
    <script src="../scripts/csrf.js"></script>
    <nav>
        <div class="typewriter">
            <h1>
                # Cross-site Request Forgery CSRF.
            </h1>
        </div>
        
        <a href="../index.html"><h1 class="back-btn">../Back</h1></a>

    </nav>
    <h1>
        ## About Cross-site Request Forgery
    </h1>
    <p>
        Cross-site request forgery, also known as one-click attack or session riding and abbreviated as CSRF 
        (sometimes pronounced sea-surf) or XSRF, is a type of malicious exploit of a website where unauthorized 
        commands are submitted from a user that the web application trusts. There are many ways in which a 
        malicious website can transmit such commands; specially-crafted image tags, hidden forms, and JavaScript 
        XMLHttpRequests, for example, can all work without the user's interaction or even knowledge. 
        Unlike cross-site scripting (XSS), which exploits the trust a user has for a particular site, 
        CSRF exploits the trust that a site has in a user's browser.

        In a CSRF attack, an innocent end user is tricked by an attacker into submitting a web request that 
        they did not intend. This may cause actions to be performed on the website that can include 
        inadvertent client or server data leakage, change of session state, or manipulation of an end user's account.
    
        The term "CSRF" is also used as an abbreviation in defences against CSRF attacks, such as techniques 
        that use header data, form data, or cookies, to test for and prevent such attacks.
    </p>
    <p>
        CSRF commonly has the following characteristics:
    </p> 
    <ul>
        <li>It involves sites that rely on a user's identity.</li>
        <li>It exploits the site's trust in that identity.</li>
        <li>It tricks the user's browser into sending HTTP requests to a target site.</li>
        <li>It involves HTTP requests that have side effects.</li>
    </ul>


    <h1>
        ## Preventive measures
    </h1>
    <ul>
        <li id="li-0" class="link" onclick="toggle_description(this.id);">Synchronizer token pattern</li>
        <div class="drop-item">
            <p> Synchronizer token pattern (STP) is a technique where a token, secret and unique value for each request, is embedded by the web application in all HTML forms and verified on the server side. The token may be generated by any method that ensures unpredictability and uniqueness (e.g. using a hash chain of random seed). The attacker is thus unable to place a correct token in their requests to authenticate them.</p>
        </div>
        <li id="li-1" class="link" onclick="toggle_description(this.id);">Cookie-to-header token</li>
        <p class="drop-item">Ahoj</p>
        <li id="li-2" class="link" onclick="toggle_description(this.id);">Double Submit Cookie</li>
        <p class="drop-item">Ahoj</p>
        <li id="li-3" class="link" onclick="toggle_description(this.id);">SameSite cookie attribute</li>
        <p class="drop-item">An additional "SameSite" attribute can be included when the server sets a cookie, instructing the browser on whether to attach the cookie to cross-site requests. If this attribute is set to "strict", then the cookie will only be sent on same-site requests, making CSRF ineffective. However, this requires the browser to recognise and correctly implement the attribute.</p>
        <li id="li-4" class="link" onclick="toggle_description(this.id);">Client-side safeguards</li>
        <p class="drop-item">Ahoj</p>
    </ul>

    <h1>
        ## Demo Example
    </h1>
    <p> 
        There is a simple authentication form below, which can be used to gain access to bitcoin accounts.
        For simplicity, each user can directly send funds to Alice through 'Amount to be sent' form field.
        The API endpoint 'POST /wallet/send' is vulnerable, due to disabled same-origin policy (it behaves
        like a public API endpoint, accepting cross-site requests). You can gain access to Bob's account using
        his credentials below:
    </p>
    <p>
        Bob's credentials:
    </p>
    <ul>
        <li>Username: Bob</li>
        <li>Password: 1234</li>
    </ul>
    <p> 
        An unknown person just sent you an email with a link leading to unknown website. Once logged in, you can go to that site
        by clicking on the 'Click me!' button. 
    </p>

    <div class="row" style="margin: 1% 0%;">
        <form id="auth-form" class="auth window">
            <div class="auth column">
                Enter your username:
                <input type="text" name="username">
            </div>
    
            <div class="auth column">
                Enter your password:
                <input type="password" name="password">
            </div>

            <div id="auth-error-message" class="auth column error-message"></div>
    
            <div class="auth login-btn" onclick="log_in();">Log In</div>
        </form>

        <form id="wallet-form" class="wallet window">
            <div class="wallet column">
                Logged in as:
                <input id="wallet-id" type="text" name="total" disabled value="">
            </div>

            <div class="wallet column">
                Total balance:
                <input id="wallet-balance" type="text" name="total" disabled value="">
            </div>
    
            <div class="wallet column">
                Amount to be sent (to Alice):
                <input id="wallet-value" type="number" min="0" name="amount">
            </div>

            <div id="wallet-error-message" class="auth column error-message"></div>
            <div class="wallet send-btn" onclick="send_funds();">Send</div>
            <div class="wallet logout-btn" onclick="log_out();">Log out</div>
        </form>

        <div class="help"><div id="evil-btn" class="help btn evil" onclick="go_to_evil_site();">Click me!</div></div>
    </div>

    <div id="explanation">
        <p> 
            As you can see, Eve just stole 25 bitcoins from you without even noticing. If you want to verify, that Eve received
            Bob's bitcoins, you can log out of Bob's account and log into her account with Eve's credentials below:
        </p>
        <p>
            Eve's credentials
        </p>
        <ul>
            <li>Username: Eve</li>
            <li>Password: 1234</li>
        </ul>
    </div>

    <h2>
        ### What happened?
    </h2>
    <p> 
        Each time you log into an account, the new session is created and appropriate session cookie is set. This cookie
        is sent with each request on target website, ensuring that once user is logged in, the entire web application can
        be used without the need of re-authenticating user while performing various actions and visiting different pages.
    </p>
    <p> 
        This feature will work if you switch browser tabs as well, thus Cross-site Request Forgery attack is possible.
        Once Eve's site is visited, malicious scripts gets executed, which targets the specific vulnerable '/wallet/send'
        endpoint. The request is constructed in such way, that credentials are required, which results in browser passing
        the session cookie together with the request. The vulnerable endpoint then match this session with currently 
        authenticated Bob and serves such request on his behalf.
    </p>

    <h2>
        ### Protection example : Security token
    </h2>
    <p> 
        One simple way how to defend against such attacks is the use of unique tokens. Such token can be generated
        for each critical part of the web application and temporarily saved on server side. Client will receive
        this token and save it samewhere safe. If a critical operation is required to be performed (sending funds in 
        this case), the token must be bundled up into the request and server verifies it before the request gets served.
    </p>
    <p> 
        Since Eve's malicious site can't access the token stored within forms attributes, server will reject her request.
        Log into Bob's account, enable security measure by checkbox below and go to Eve's site. This time, Bob's bitcoins
        are safe and sound.
    </p>

    <div class="security row">
        <p>Enable security measure: (Token)</p>
        <div id="enable-security" class="" onclick="toggle_checkbox(this.id);"></div>
    </div>

    <footer>
        Created by Michal Rein, 2022
    </footer>

</body>
</html>